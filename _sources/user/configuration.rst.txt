Configuration
=============

The Design
----------

The design of the configuration system is one I've struggled with a bit.

I'm a strong proponent of *dependency injection* and the *inversion of control* principle. The overwhelming majority of
SimplePie NG is built like this by default.

Then I started looking at what a global configuration system would look like. As a user, I want to be able to pass-in
my logger when I get started, then trust that it will be used throughout. Following a *strict* view of inversion of
control, this means that I have to pass the logger object down throughout every single instantiated object in the tree.
*Every single constructor* would have to accept my logger.

When I started doing this, however, the public API started to get really gnarly. Even in my development sandbox file, I
was having to pass the logger to ``SimplePie``, ``HandlerStack``, and then into each and every single piece of
middleware I used individually.

Conversely, you have the *service locator pattern* wherein you use your container as a central registry. Every class
which needs something from the registry knows how to pull it. Slim Framework leverages this pattern for a few things
like the various 400/500 error handlers. Some people refer to this as an *anti-pattern* because, when used flagrantly,
you completely lose track of your class dependencies. But I think that in well-understood, limited cases, it can come in
handy. Namely, for the logger and other global-style configurations that should apply universally.

So that's what this is — documentation for *configuration options* which leverage the service locator pattern, while the
rest of SimplePie NG uses plain ol' dependency injection.

Logger
------

Using any `PSR-11 <https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-11-container.md>`__ container,
create a new key called ``simplepie.logger``, then have it return any instantiated
`PSR-3 <http://www.php-fig.org/psr/psr-3/>`__ logger.

Here’s an example `Monolog <https://github.com/Seldaek/monolog>`__ logger that uses the system’s error log.

.. code-block:: php

    <?php
    use Monolog\Handler\ErrorLogHandler;
    use Monolog\Logger;
    use Psr\Container\ContainerInterface;
    use Psr\Log\LogLevel;
    use SimplePie\Configuration;
    use SimplePie\Container;
    use SimplePie\SimplePie;

    $container = new Container();

    $container['simplepie.logger'] = function (ContainerInterface $c)
    {
        $logger = new Logger('SimplePie');
        $logger->pushHandler(new ErrorLogHandler(
            ErrorLogHandler::OPERATING_SYSTEM,
            LogLevel::DEBUG,
            true,
            false
        ));

        return $logger;
    }

    Configuration::setContainer($container);

    $simplepie = new SimplePie();

Middleware
----------

All of the parsing leverages a middleware pattern. Without any registered middleware, nothing happens by default. All
of this is managed using a *middleware handler stack*.

Using any `PSR-11 <https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-11-container.md>`__ container,
create a new key called ``simplepie.middleware``, then have it return an instantiated class which implements
`SimplePie\HandlerStackInterface` (such as `SimplePie\HandlerStack`).

.. code-block:: php

    <?php
    use SimplePie\Configuration;
    use SimplePie\Container;
    use SimplePie\HandlerStack;
    use SimplePie\Middleware\Json\JsonFeed;
    use SimplePie\Middleware\Xml\Atom;
    use SimplePie\Middleware\Xml\Rss;
    use SimplePie\SimplePie;

    $container = new Container();

    $container['simplepie.middleware'] = function (ContainerInterface $c)
    {
        return (new HandlerStack())
            ->append(new JsonFeed(), 'jsonfeed')
            ->append(new Atom(), 'atom10')
            ->append(new Rss(), 'rss20');
    }

    Configuration::setContainer($container);

    $simplepie = new SimplePie();

In this example, and assuming the feed is XML-based, the Atom 1.0 middleware will run first followed by the RSS 2.0
middleware.

* If it's an RSS 2.0 feed, it is likely that the Atom 1.0 middleware will have limited results while the RSS 2.0
  middleware will populate the results. Since Atom can be embedded inside RSS 2.0 feeds (e.g., ``<atom:enabled>``), it
  is possible that the Atom middleware will pick up a few matching elements.

* If it's an Atom 1.0 feed, it is likely that the Atom 1.0 middleware will populate the results while the RSS 2.0
  middleware will have no results.

For more information on how to write custom middleware, see @todo.

libxml
------

The ``libxml`` settings that are used by default provide the best support for the widest variety of XML-based feeds.
They are as follows:

+---------------------------+------------------------------------------------------------------------------------------+
| ``libxml`` constant       | Description                                                                              |
+===========================+==========================================================================================+
| ``LIBXML_BIGLINES``       | Allows line numbers greater than 65535 to be reported correctly.                         |
+---------------------------+------------------------------------------------------------------------------------------+
| ``LIBXML_COMPACT``        | Activates small nodes allocation optimization. This may speed up your application        |
|                           | without needing to change the code.                                                      |
+---------------------------+------------------------------------------------------------------------------------------+
| ``LIBXML_HTML_NODEFDTD``  | Sets ``HTML_PARSE_NODEFDTD`` flag, which prevents a default doctype being added when one |
|                           | is not found.                                                                            |
+---------------------------+------------------------------------------------------------------------------------------+
| ``LIBXML_HTML_NOIMPLIED`` | Sets ``HTML_PARSE_NOIMPLIED`` flag, which turns off the automatic adding of implied      |
|                           | ``html``/``body``\ … elements. This is **required** otherwise parsing will fail.         |
+---------------------------+------------------------------------------------------------------------------------------+
| ``LIBXML_NOBLANKS``       | Remove blank nodes.                                                                      |
+---------------------------+------------------------------------------------------------------------------------------+
| ``LIBXML_NOENT``          | Substitute entities in the XML.                                                          |
+---------------------------+------------------------------------------------------------------------------------------+
| ``LIBXML_NOXMLDECL``      | Drop the XML declaration when saving a document.                                         |
+---------------------------+------------------------------------------------------------------------------------------+
| ``LIBXML_NSCLEAN``        | Remove redundant namespace declarations.                                                 |
+---------------------------+------------------------------------------------------------------------------------------+
| ``LIBXML_PARSEHUGE``      | Sets ``XML_PARSE_HUGE`` flag, which relaxes any hardcoded limit from the parser. This    |
|                           | affects limits like maximum depth of a document or the entity recursion, as well as      |
|                           | limits of the size of text nodes.                                                        |
+---------------------------+------------------------------------------------------------------------------------------+

We explicitly do not set ``LIBXML_NOCDATA`` because we want to preserve the *CDATA-ness* of those nodes. You can find
the definitions for more ``libxml`` constants by reading
`Predefined libxml constants <http://php.net/manual/en/libxml.constants.php>`__.

If you want to change the ``libxml`` parameters that are used, using any
`PSR-11 <https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-11-container.md>`__ container, create a new
key called ``simplepie.libxml``, then have it return the
`bitwise-OR <http://php.net/manual/en/language.operators.bitwise.php>`__ value of the ``LIBXML_*`` options you prefer.

.. code-block:: php

    <?php
    use SimplePie\Configuration;
    use SimplePie\Container;
    use SimplePie\SimplePie;

    $container = new Container();

    $container['simplepie.libxml'] = function ()
    {
        return LIBXML_HTML_NOIMPLIED | LIBXML_NOCDATA;
    }

    Configuration::setContainer($container);

    $simplepie = new SimplePie();

.. reviewer-meta::
   :written-on: 2017-06-25
   :proofread-on: 2017-06-30
